use itertools::Itertools;
use std::iter::zip;
pub trait Ocr {
    fn ocr(&self, width: usize) -> String;
}

impl Ocr for &str {
    fn ocr(&self, width: usize) -> String {
        let lines: Vec<Vec<_>> = self
            .chars()
            .chunks(width)
            .into_iter()
            .map(|chunk| {
                chunk
                    .chunks(5)
                    .into_iter()
                    .map(|char_line| char_line.collect_tuple().unwrap())
                    .collect()
            })
            .collect();

        zip(
            &lines[0],
            zip(&lines[1], zip(&lines[2], zip(&lines[3], zip(&lines[4], &lines[5])))),
        )
        .map(|(a, (b, (c, (d, (e, f)))))| match (a, b, c, d, e, f) {
            (
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', '#', ' ', ' '),
                ('#', '#', ' ', ' ', ' '),
                ('#', ' ', '#', ' ', ' '),
                ('#', ' ', '#', ' ', ' '),
                ('#', ' ', ' ', '#', ' '),
            ) => 'K',
            (
                ('#', '#', '#', '#', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', '#', '#', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', '#', '#', '#', ' '),
            ) => 'E',
            (
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', '#', '#', '#', ' '),
            ) => 'L',
            (
                (' ', '#', '#', ' ', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', ' ', '#', ' '),
                (' ', '#', '#', ' ', ' '),
            ) => 'C',
            (
                (' ', ' ', '#', '#', ' '),
                (' ', ' ', ' ', '#', ' '),
                (' ', ' ', ' ', '#', ' '),
                (' ', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                (' ', '#', '#', ' ', ' '),
            ) => 'J',
            (
                ('#', '#', '#', '#', ' '),
                (' ', ' ', ' ', '#', ' '),
                (' ', ' ', '#', ' ', ' '),
                (' ', '#', ' ', ' ', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', '#', '#', '#', ' '),
            ) => 'Z',
            (
                (' ', '#', '#', ' ', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', '#', '#', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
            ) => 'A',
            (
                (' ', '#', '#', ' ', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', ' ', ' '),
                ('#', ' ', '#', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                (' ', '#', '#', '#', ' '),
            ) => 'G',
            (
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                ('#', ' ', ' ', '#', ' '),
                (' ', '#', '#', ' ', ' '),
            ) => 'U',
            _ => unimplemented!(),
        })
        .collect()
    }
}


impl Ocr for String{
    fn ocr(&self, width: usize) -> String {
        self.as_str().ocr(width)
    }
}
